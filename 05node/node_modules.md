

```
npm install cnpm -g --registry=https://r.npm.taobao.org
cnpm sync [moduleName]
sudo rm -rf node_modules package-lock.json 
sudo npm install
npm cache clean --force
npm rebuild node-sass
npm install --cache /tmp/empty-cache
```













我们目前在应用的代码里，为了防止某些包在升级过程中，没有遵循语义化版本，导致我们应用在每次打包后，生成的代码可能不同，一般都会用 `yarn.lock` 或者 `package-lock.json` 来锁定项目依赖的包的版本号。

但是上次有同学在开源的 **第三方包** 里，发现大多数都**没有** `yarn.lock` 或者 `package-lock.json`，感到有点奇怪，为什么这些开源的包，不锁定依赖的第三方版本呢？

我的理解，大概是这两个方面：

1. 都说`nodejs`的 `node_modules`是个比黑洞还深的坑，可见通常在我们一个应用里，会依赖多少的第三方开源包。每一个开源包，又会依赖很多别的包。如果每个开源包都锁定自己的依赖版本，那么很多底层的基础包，可能会被安装很多个，虽然只是 `patch` 部分存在版本差异，那前端代码打包之后，体积无疑会增大很多。因此，开源包为了和其他的开源包 **共享** 更底层的包，就不能锁定自己的版本
2. 其实第一点已经说明了问题，作为开源包的作者，可能也没有其他选择了，只能选择**相信** 其他的开源包作者，都会严格遵守 **语义化版本** 的要求

如果你的lock指定的是0.12,那么就只会下载这个0.12版本,有^符号也没有用,npm install不会更新, 如果你执行"npm install hard-source-webpack-plugin"单独安装这个包,就会更新了,但是我没懂这个更新的机制是怎样的,为什么能摆脱lock的限制,还是说lock文件只能限制npm install而不能限制npm install某个包?



`^`指明的版本范围，只要**不**修改 **[major, minor, patch]** 三元组中，**最左侧的第一个非0位**，都是可以的。也就是说，要确定 `^`版本包含的范围，先要找到 **最左侧的第一个非0位** ，只有在这一位右侧的变动，才被包含在这个 `^` 指定的范围内。

