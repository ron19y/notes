### TCP 3次握手



![img](https://user-gold-cdn.xitu.io/2018/5/1/1631bf1e79b3cd42?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。

起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入  SYN-SENT 状态，`x` 表示客户端的数据通信初始序号。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。

**你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？**

因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。

可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。

PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。

## 四次挥手

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

> **为什么要四次挥手**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

### TCP 拥塞控制

拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。

拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。

### 慢开始算法

慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。

慢开始算法步骤具体如下

1. 连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）
2. 每过一个 RTT 就将窗口大小乘二
3. 指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。

### 拥塞避免算法

拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。

在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：

- 将阈值设为当前拥塞窗口的一半
- 将拥塞窗口设为 1 MSS
- 启动拥塞避免算法





























**TCP New Reno** 算法改进了之前 **TCP Reno** 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。

在 **TCP New Reno** 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。

假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。

 



第一眼从目录结构上，chromium包含这些东西：

- **base**，通用代码，基础组件，包含字符串、文件、线程、消息队列等工具类集合。
- **cc**，Chromium compositor 的缩写，负责渲染合成。
- **chrome**，Chromium 浏览器外壳实现。
- **content**，多进程沙盒浏览器的核心代码，管理进程架构和线程架构。
- **gpu**，OpenGL 封装代码，包含 CommandBuffer 和 OpenGL 兼容性支持等。
- **net**，网络栈实现。
- **ipc**，进程间消息通信实现。
- **media**，多媒体封装代码，包含了媒体内容捕获和播放的组件集合。
- **mojo**，类似于 Android 的 AIDL，提供了跨语言（C++ / Java / JavaScript）跨平台的进程间对象（Object）通信机制；。
- **skia**，图形库，这里存放的是 Chromium 对 skia 的 配置和扩展代码，另有 third_party/skia 目录存放原生的 skia 代码。
- **third_party**，网页排版引擎。第三方库
- **ui**，UI 框架。
- **v8**，V8 JavaScript 引擎库。

看起来还好吧？但实际上，这里面每一个展开来讲，都是一本厚厚的工具书的容量。

比如net，看起来只是个网络库，然而里面包含主机解析，cookies，网络改变探测，SSL，资源缓存，ftp，HTTP， OCSP实现，代理 (SOCKS和HTTP) 配置，解析，脚本获取（包括各种不同系统下实现），QUIC，socket池，SPDY，WebSockets……里面每一项展开来讲，又是一本书。

v8层，看起来功能很单一，只是实现一下js嘛，但里面包括字节码解析器，JIT 编译器，多代GC，inspector (调试支持)，内存和 CPU 的 profiler（性能统计），WebAssembly 支持，两种 post-mortem diagnostics 的支持，启动快照，代码缓存、代码热点分析……里面每一项展开来讲，又是一本书，还是难坑的编译原理和优化方向。

Skia，看起来只是个图形库嘛，用点画出各种图。然而里面包括十几种矢量的绘制，文字绘制、GPU加速、矢量的指令录制以及回放（还要能支持线程安全）、各种图像格式的编解码、PDF的生成（这个是个隐藏的很深的功能，但很有趣。Skia支持把矢量图绘制成pdf）、GPU渲染优化（既以上部分功能需要用gpu来渲染）……里面每项展开来讲，又是一本书。另外值得一提的是，skia是谷歌收购的。不知道谷歌是觉得自己没实力做，还是太费功夫。总之谷歌选择了直接买别人的代码来完成这些功能。

ui，看起来只是一套UI 框架嘛。然而chromium需要一套全平台适配的ui库，还要能支持gpu加速。不过可惜的是里面没实现richedit。ui库的设计，深入来做，其实可以说又是个浏览器了。

等等，以上这些，看起来只是浏览器的外层。我们最关心的网页排版呢？这个难道不是浏览器的核心嘛。是的，chromium奇特的把排版引擎blink放到了third_party下，而且真的当成了一个第三方库一样对待。据谷歌的员工说，这是历史原因……好吧姑且信了。然而这个第三方库，成了当之无愧的最复杂，功能最重要的第三方库。

blink的工作包括：

- 实现web平台的规范（例如，HTML标准），包括DOM，CSS和Web IDL
- 配合V8运行JavaScript
- 从底层网络堆栈请求资源
- 构建DOM树
- 计算样式和布局
- 请求chrome compositor（上文提到的cc层）并绘制图形。

说起来简单。看一下现在的HTML、CSS规范，各种细节加起来……有快上万页。除了chromium layout组、firefox的工作人员，我想没几个人会去仔细阅读并一个个的实现这些规范吧。光是看目录和文字描述，就头大了，更别说要完整的实现出来。往往一个简单的display:gird\flex背后就是庞大复杂的计算，而且还要充分考虑性能上如何优化，滚动时如何更快的展示…

另外排版还需要支持世界各国的奇奇怪怪的文字。例如从右往左写、规则复杂无比阿拉伯文，天城文。相比之下，汉字这种方块字的排版简直就是弟弟。还有各种奇怪的unicode字符。

[【转】奇怪的unicode字符](https://link.zhihu.com/?target=http%3A//zyho.me/index.php%3Faction%3Dblog%26tid%3D83)

![img](https://pic2.zhimg.com/50/v2-713e78d8bd56481a136102aada484180_hd.jpg)![img](https://pic2.zhimg.com/80/v2-713e78d8bd56481a136102aada484180_720w.jpg)

怎么能处理好这些字符和语言，并配合几千页的html、css排版规则正确显示出来……这是个极度烧脑的事情。

我们再从排版这个大泥坑里跳出来看看外面别的东西。这时候你会发现……原来外面的泥坑好像更大。

随便说几个，比如：

- 多进程框架。嗯，你需要更多的进程来渲染更多的网页，这样才能崩溃了也不影响其他网页。注意，chromium把渲染排版放在渲染线程，但绘制到窗口又是主进程。这里面少不了各种跨进程通信、同步。对于代码的编写以及调试，是个很考验编程功底的事情。
- webrtc。网络视频相关。又是一个被收购的库。关于webrtc，你需要知道它能实现多人实时语音、降噪、网络传输视频、摄像头的捕获，音频算法实现（比如 fft），视频算法实现（比如 h264 协议格式）， Socket、线程、锁等基础库（是的，webrtc也造了套自己的轮子）。又是个庞大的组件。
- 密码管理、下载管理、扩展管理。
- 一套调度整个多进程框架以及blink的核心层。在chromium被称之为content层。负责处理了一切繁琐的细节，例如各种系统、平台的鼠标键盘消息派发，历史栈（前进后退），页面缓存。
- 沙箱机制。负责隔离以及降低子进程的权限。沙箱的实现上，在不同系统做了诸多hook操作。
- chrome相关的外壳及应用。例如我们常见的标题栏、url栏，webui如设置页、历史记录页。对，其实chrome单词的原意就是这个。
- Clound_Print，谷歌云打印相关，提供谷歌浏览器页面预览打印清单。
- Courgetter，谷歌提供的二进制文件对比核心算法，在谷歌浏览器中用于比较不同版本的二进制差异。谷歌为了方便升级，搞了套升级策略和算法。
- 神奇的syzygy优化。是的，谷歌也嫌chrome太大了，加载太慢了。于是他们开发的一套优化重排布PE二进制文件来达到优化程序的工具链。Chrome浏览器应用了Syzygy优化之后，程序冷启动的页面调度（paging traffic）优化了80%，加载的Image的Working Set优化了40%。简单的说，谷歌从编译器上对exe、dll开始做手脚了。
- Media Chrome的多媒体模块，支持音频播放和录音等功能。这里用到了ffmpeg。但在ffmpeg外，为了和blink配合，又是包裹了厚厚的一层，用来处理好渲染管线。另外MSE API也花了不少功夫。
- swiftshader。很有趣的一个模块，用纯软件的代码，完整实现了opengl的接口。可以在没有硬件加速的机器上跑起opengl。也是个庞大的库，而且也是被收购的。看起来谷歌对图形学方面的很多工程似乎不擅长？还是不想觉得应该交给更专业的团队去做。
- gn、gyp。chromium为了更方便的管理编译，自己撸了两套轮子。类似makefile、cmake。

其他的点还有很多很多，以后想到了再补充。总之，以上随意一个点，要正确的实现，都是一个团队的工作量，都可以写成一本书。然而chromium把他们全部实现了，而且还在不停的加入新的功能。

**看到这里，大家应该明白为啥强如微软，也放弃维护他们自己的浏览器内核了。**因为需要投入的人力财力实在是太恐怖了。chromium团队，光是开发人员，都已经上千了。假如每个人员年薪是100w 人民币，持续投入十年，这个支出就是**几十亿**，这还不算周边的测试、产品、UI。最关键的是，就算微软愿意投入十亿，能保证做到chromium相同的功能吗？就算能做到相同的功能，还不是另外一套chromium吗？能做出其他优势吗？所以最后微软也放弃了，干脆直接从开源的chromium上改起，把微软需要的功能融入chromium。

所以，chromium的霸权就是这么来的。看似开源免费，实则把所有开发者和对手，紧紧的捆绑在自己周围。

**好了，现在吐槽开始了。**

chromium称霸浏览器界以来，看起来开源，谁都可以拿去改。然而比起它的前辈，我觉得从“道德”上，chromium要“差”很多。最让我受不了的一点是，chromium在无尽的往里面塞功能的时候，很少想过是否别人可以轻易的移除它们。chromium代码号称模块化、高内聚低耦合，然而如果你想砍掉一些不需要的东西，对不起，没有宏控制，手动注释代码吧。有几个人能有精力一点点的去掉里面这些繁琐的功能呢？这就导致一个问题，需要chromium某一部分功能的人，必须被强塞进一堆谷歌认为你需要的东西。

对比之下，为啥我说比起chromium的前辈要差很多呢，其实我指的正是webkit。webkit最让人欣赏的一点就是它在专注实现内核的同时，大部分功能都是可“拆卸”的。有宏可以关闭。甚至连svg这种排版上的小功能都有宏可以关闭。而chromium，如果我需要排版、音视频，但不需要多进程呢？对不起，谷歌没这考虑。要带就全都带上吧。

这也就造成现在基于chromium的一堆开发框架，如electron、cef、nwjs，全都动不动100多M的大小。因为从chromium的框架设计上，就很难把那些极其庞大复杂的细节功能排除掉。这些功能对于谷歌作为一个浏览器来说，当然是必要的。然而回到本问题，“浏览器内核”真的需要这么复杂吗？浏览器需要这么复杂，这是真的；然而作为一个浏览器内核提供给一些sdk给别人用，也需要这么复杂吗？我们用electron写一套进供销管理系统的客户端，你会需要带上十几M的webrtc、webgl、多媒体播放、天城文支持吗？

最后打破这个疑问的，是我很多年后进入了QQ浏览器的移动端组（其实就是x5内核，微信上被大家吐槽最多的那个）。当年的x5内核其实是基于webkit改造的。从chromium回到webkit，我突然有种豁然开朗的感觉。从浏览器内核的角度，只要做好网络、排版、渲染，就足以应付大部分使用场景了。

然而后来组里架构调整，x5内核为了跟上时代，从webkit跳回了chromium（也是因为被骂了太多了，当时x5号称移动端IE6）。对chromium深恶痛绝的我，当时有了一个大胆的想法。把排版引擎blink（也就是webkit在chromium里的继承者）重新从chromium里剥离出来，再补上一些周边的设施、组件，再次成为一个完整独立的浏览器内核。

当然我还是有自知之明的。一个浏览器内核而已，不可能实现chromium同样的功能。但能把排版、渲染、网络、视频实现，就差不多了。其实我也不是想做个浏览器，而是想专注内核这块，做一个提供给第三方app嵌入的内核。

作为一个内核，其实不需要上面讲的所有那一大堆功能。比如，网络层，大部分人不需要什么网络改变探测，ftp，OCSP实现，代理配置、解析、脚本获取，QUIC，socket池，SPDY什么的。大部分人仅仅需要一个http的实现，可以拉取到服务器资源。我用300k的curl代替了十余M的chromium net库，并工作良好。少了的功能可以用插件形式补上嘛。一些和排版渲染无关的功能，我都打算做成插件。例如音视频、webgl、webrtc、多进程等。

目前这个项目已经撸了5年了，开源在github上，提供C接口方便其他语言调用。整个编译出来就是一个1-20m左右的dll（视编译选项而定），甚至还包含了一个electron的精简实现：



![img](https://pic4.zhimg.com/80/v2-77eb26c84a4f0b3918e67420cb526e54_720w.jpg)



 