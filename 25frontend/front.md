## PWA 的优势在哪？ 

- **消息推送**。用户只要允许，即使网页关闭后仍然可以在系统通知栏收到推送消息。 
- **后台加载**。往常的网页应用只要关闭了网页他的生命就结束了，现在引入了一个 Service Worker 的概念，即使网页关闭，PWA 仍然可以在后台运行获取数据更新（当然有限制）。
- **离线使用**。PWA 打开后会缓存一些内容，之后再次访问即使没有网络也可以浏览之前的页面（如同IE时代的离线浏览）。
- **原生应用界面**。在某些情况下 PWA 应用可以隐藏浏览器本身的所有视觉成分，光从UI和UX上看，很容易认为这就是一个原生界面，如下图其实都是PWA而不是原生应用。
- **桌面图标**。PWA只要配上一个图标，再放快捷方式在桌面上（比如一定时间内第二次访问PWA会自动询问是否添加快捷方式到桌面），就真的和原生系统无异了，打开的速度也很快（当然功能不能很庞大）。  

## WebAssembly 

源于Mozilla 发起的 Asm.js 项目，设计补充而非取代 JavaScript， 它是一个二进制格式，容易翻译到原生代码，本地解码速度比 JS 解析快得多，让高性能的 Web 应用在浏览器上运行成为可能，比如视频游戏、计算机辅助设计、视频和图像编辑、科学可视化等等。未来，现有的生产力应用和 JavaScript 框架都有可能使用 WebAssembly，能显著降低加载速度，同时改进运行性能。开发者可以将针对 CPU 密集计算的 WebAssembly 库整合到现有的 Web 应用中。

## 无服务器运算（英语：Serverless computing）

又被称为函数即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。 国内外此类型产品，诸如 Tencent Serverless、AWS Lambda、Microsoft Azure Functions 等



FAAS（函数即服务） + BAAS（后台即服务） 可以称为一个完整的 Serverless 的实现，除此之外，还有 PASS（平台即服务）的概念。而通常平台环境都通过容器技术实现，最终都为了达到 NoOps（无人运维），或者至少 DevOps（开发&运维）。

简单介绍一下这几个名词，防止大家被绕晕：

**FAAS** - Function as a service

函数即服务，每一个函数都是一个服务，函数可以由任何语言编写，除此之外不需要关心任何运维细节，比如：计算资源、弹性扩容，而且可以按量计费，且支持事件驱动。业界大云厂商都支持 FAAS，各自都有一套工作台、或者可视化工作流来管理这些函数。

**BAAS** - Backend as a service

后端及服务，就是集成了许多中间件技术，可以无视环境调用服务，比如数据即服务（数据库服务），缓存服务等。虽然下面还有很多 `XASS`，但组成 Serverless 概念的只有 FAAS + BAAS。

**PAAS** - Platform as a service

平台即服务，用户只要上传源代码就可以自动持续集成并享受高可用服务，如果速度足够快，可以认为是类似 Serverless。但随着以 Docker 为代表的容器技术兴起，以容器为粒度的 PASS 部署逐渐成为主流，是最常用的应用部署方式。比如中间件、数据库、操作系统等。

**DAAS** - Data as a service

数据即服务，将数据采集、治理、聚合、服务打包起来提供出去。DASS 服务可以应用 Serverless 的架构。

**IAAS** - Infrastructure as a Service

基础设施即服务，比如计算机存储、网络、服务器等基建设施以服务的方式提供。

**SAAS** - Software as a Service

软件即服务，比如 ERP、CRM、邮箱服务等，以软件为粒度提供服务。

**容器**

容器就是隔离了物理环境的虚拟程序执行环境，而且环境可被描述、迁移。比较热门的容器技术是 Docker。

随着容器数量增多，就出现了管理容器集群的技术，比较有名的容器编排平台是 Kubernetes。容器技术是 Serverless 架构实现的一种选择，也是实现的基础。

k8s  + docker

**NoOps**

就是无人运维，比较理想主义，也许要借助 AI 的能力才能实现完全无人运维。

无人运维不代表 Serverless，Serverless 可能也需要人运维（至少现在），只是开发者不再需要关心环境。

**DevOps**

笔者觉得可以理解为 “开发即运维”，毕竟出了事情，开发要被问责，而一个成熟的 DevOps 体系可以让更多的开发者承担 OP 的职责，或者与 OP 更密切的合作。





dubbo + zookeeper	eureka + feign

RocketMQ	Kafka

netty

k8s + docker

